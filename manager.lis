     1                                  ;==============================================================================================================
     2                                  ;Program name: "Harmonic Sum". This program is meant to calculate the 
     3                                  ;   Harmonic Sum of an inputted integer. Copyright (C) 2020 Dennis Newman
     4                                  ;This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License  *
     5                                  ;version 3 as published by the Free Software Foundation.                                                                    *
     6                                  ;This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied         *
     7                                  ;Warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.     *
     8                                  ;A copy of the GNU General Public License v3 is available here:  <https://www.gnu.org/licenses/>.
     9                                  ;==============================================================================================================
    10                                  
    11                                  ;==============================================================================================================
    12                                  ;Author Information
    13                                  ;       Author Name: Dennis Newman
    14                                  ;       Author email: dlnew3@csu.fullerton.edu
    15                                  ;;
    16                                  ;Program Information
    17                                  ;   Program Name: Harmonic Sum
    18                                  ;   Program Languages: One module in C++, two modules in x86
    19                                  ;   Date Program began: Dec. 8, 2020
    20                                  ;   Date Program completed:
    21                                  ;   Files in this program: main.cpp, manager.asm, read_clock.asm, r.sh
    22                                  ;   Status: In Progress
    23                                  ;;
    24                                  ;References for this program
    25                                  ;   Jorgensen, X86-64 Assembly Language Programming with Ubuntu, Version 1.1.40.
    26                                  ;;
    27                                  ;This File
    28                                  ;   File Name: manager.asm
    29                                  ;   Language: x86-64 with Intel Syntax
    30                                  ;   Assemble: nasm -f elf64 -l manager.lis -o manager.o manager.asm
    31                                  
    32                                  ;======= Beginning of Code Area ===================================================================================================
    33                                  
    34                                  extern printf               ;External C++ function for writing to standard output devices
    35                                  extern scanf                ;External C++ function for reading from standard input devices
    36                                  extern getfreq          ;User-Defined function
    37                                  ;extern atof
    38                                  
    39                                  
    40                                  ;==================================================================================================================================
    41                                  segment .data               ;Initialized Data goes here
    42                                  
    43 00000000 0000000000000000        start_tics dq 0
    44 00000008 0000000000000000        close_tics dq 0
    45 00000010 0000000000000000        input dq 0
    46 00000018 0000000000000000        output dq 0
    47 00000020 000000000000F03F        fHarmonNumerator dq 1.0
    48                                  
    49 00000028 256C6400                numberFormat db "%ld", 0
    50 0000002C 257300                  stringFormat db "%s", 0
    51                                  
    52 0000002F 506C6561736520656E-     input_msg db "Please enter the number of terms to be included in the sum: ", 10, 0
    52 00000038 74657220746865206E-
    52 00000041 756D626572206F6620-
    52 0000004A 7465726D7320746F20-
    52 00000053 626520696E636C7564-
    52 0000005C 656420696E20746865-
    52 00000065 2073756D3A200A00   
    53 0000006D 4572726F723A20496E-     error_msg db "Error: Inputted value is not a positive integer, closing program...", 10, 0
    53 00000076 707574746564207661-
    53 0000007F 6C7565206973206E6F-
    53 00000088 74206120706F736974-
    53 00000091 69766520696E746567-
    53 0000009A 65722C20636C6F7369-
    53 000000A3 6E672070726F677261-
    53 000000AC 6D2E2E2E0A00       
    54 000000B2 0A54686520636C6F63-     initial_tics db 10, "The clock is now %ld tics and the computation will begin.", 10, 0
    54 000000BB 6B206973206E6F7720-
    54 000000C4 256C64207469637320-
    54 000000CD 616E64207468652063-
    54 000000D6 6F6D7075746174696F-
    54 000000DF 6E2077696C6C206265-
    54 000000E8 67696E2E0A00       
    55 000000EE 0A5465726D7320636F-     column_head db 10, "Terms completed", 9, "Harmonic sum", 10 , 0
    55 000000F7 6D706C657465640948-
    55 00000100 61726D6F6E69632073-
    55 00000109 756D0A00           
    56 0000010D 09256C6409252E3138-     row_hsum db 9, "%ld", 9, "%.18lf", 10, 0
    56 00000116 6C660A00           
    57 0000011A 0A54686520636C6F63-     final_tics db 10, "The clock is now %ld tics.", 10, 0
    57 00000123 6B206973206E6F7720-
    57 0000012C 256C6420746963732E-
    57 00000135 0A00               
    58 00000137 54686520656C617073-     time db "The elapsed time was %ld tics, which equals %lf seconds", 10, 0
    58 00000140 65642074696D652077-
    58 00000149 617320256C64207469-
    58 00000152 63732C207768696368-
    58 0000015B 20657175616C732025-
    58 00000164 6C66207365636F6E64-
    58 0000016D 730A00             
    59 00000170 546865206861726D6F-     exit_msg db "The harmonic sum will be returned to the driver.", 10, 0
    59 00000179 6E69632073756D2077-
    59 00000182 696C6C206265207265-
    59 0000018B 7475726E656420746F-
    59 00000194 207468652064726976-
    59 0000019D 65722E0A00         
    60                                  
    61                                  ;============Debug Statements==============
    62 000001A2 436C6F636B20537065-     dbg_getfreq db "Clock Speed is %f GHz", 10, 0
    62 000001AB 656420697320256620-
    62 000001B4 47487A0A00         
    63 000001B9 43757272656E742074-     dbg_tics db "Current tics = %ld tics", 10, 0
    63 000001C2 696373203D20256C64-
    63 000001CB 20746963730A00     
    64 000001D2 456C61707365642073-     dbg_seconds db "Elapsed seconds = %lf seconds", 10, 0
    64 000001DB 65636F6E6473203D20-
    64 000001E4 256C66207365636F6E-
    64 000001ED 64730A00           
    65 000001F1 526563656976656420-     dbg_input db "Received input = %ld.", 10, 0
    65 000001FA 696E707574203D2025-
    65 00000203 6C642E0A00         
    66 00000208 426C6F636B20636F6D-     dbg_block_conf db "Block completed", 10, 0 
    66 00000211 706C657465640A00   
    67 00000219 256C660A00              dbg_float db "%lf", 10, 0
    68                                  ;============Debug Statements==============
    69                                  
    70                                  global hsum     	        ;Makes manager callable by functions outside of file.
    71                                  
    72                                  segment .bss
    73                                  
    74                                  
    75                                  segment .text
    76                                  hsum:
    77                                  
    78                                  ;==================================== Back-up GPRs ====================================
    79 00000000 55                        push  rbp         ;Save a copy of the stack base pointer
    80 00000001 4889E5                    mov   rbp, rsp    ;We do this in order to be 100% compatible with C and C++.
    81 00000004 53                        push  rbx         ;Back up rbx
    82 00000005 51                        push  rcx         ;Back up rcx
    83 00000006 52                        push  rdx         ;Back up rdx
    84 00000007 56                        push  rsi         ;Back up rsi
    85 00000008 57                        push  rdi         ;Back up rdi
    86 00000009 4150                      push  r8          ;Back up r8
    87 0000000B 4151                      push  r9          ;Back up r9
    88 0000000D 4152                      push  r10         ;Back up r10
    89 0000000F 4153                      push  r11         ;Back up r11
    90 00000011 4154                      push  r12         ;Back up r12
    91 00000013 4155                      push  r13         ;Back up r13
    92 00000015 4156                      push  r14         ;Back up r14
    93 00000017 4157                      push  r15         ;Back up r15
    94 00000019 9C                        pushf             ;Back up rflags
    95                                  
    96                                  ;======================================================================================
    97                                  
    98                                  ;===================================Debug Section================================================
    99                                  ;; DEBUG getfreq
   100 0000001A 4831C0                  xor rax, rax
   101 0000001D E8(00000000)            call getfreq
   102 00000022 B801000000              mov rax, 1
   103 00000027 48BF-                   mov rdi, dbg_getfreq
   103 00000029 [A201000000000000] 
   104                                  ;call printf
   105                                  ;; DEBUG getfreq _END
   106                                  
   107                                  
   108                                  
   109                                  
   110                                  ;; DEBUG SECONDS
   111                                  ; getfreq -> xmm15
   112 00000031 4831C0                  xor rax, rax
   113 00000034 E8(00000000)            call getfreq
   114 00000039 4C8B3C25[08000000]      mov r15, [close_tics]
   115 00000041 4C2B3C25[00000000]      sub r15, [start_tics]
   116 00000049 F24D0F2AEF              cvtsi2sd xmm13, r15
   117 0000004E B800000000              mov rax, 0
   118 00000053 F2440F10F8              movsd xmm15, xmm0
   119                                  ; Math part
   120 00000058 49BD0000000065CDCD-     mov r13, 0x41cdcd6500000000	; 1 billion
   120 00000061 41                 
   121 00000062 664D0F6EE5              movq xmm12, r13				; xmm12 = 1bil
   122 00000067 F2450F10F7              movsd xmm14, xmm15			; xmm14 = Clock Speed
   123 0000006C F2450F59F4              mulsd xmm14, xmm12			; xmm14 = Clock Speed * 1bil
   124 00000071 F2450F5EEE              divsd xmm13, xmm14			; xmm13 = Elapsed time / (GHz * 1bil)
   125                                  ; printf part
   126 00000076 B801000000              mov rax, 1
   127 0000007B 48BF-                   mov rdi, dbg_seconds
   127 0000007D [D201000000000000] 
   128 00000085 4C89FE                  mov rsi, r15
   129 00000088 F2410F10C5              movsd xmm0, xmm13
   130                                  ;call printf
   131                                  ;; DEBUG SECONDS _END
   132                                  ;===================================Debug Section================================================
   133                                  
   134                                  
   135                                  ;;	Input Message
   136 0000008D B800000000              mov rax, 0
   137 00000092 48BF-                   mov rdi, input_msg
   137 00000094 [2F00000000000000] 
   138 0000009C E8(00000000)            call printf
   139                                  ;;	Input Message _END
   140                                  
   141                                  ;;	Receive input
   142 000000A1 48BF-                   mov qword rdi, numberFormat
   142 000000A3 [2800000000000000] 
   143 000000AB 6AFF                    push qword -1                     	;Reserve space for input
   144 000000AD 6AFF                    push qword -1
   145 000000AF 4889E6                  mov qword rsi, rsp               	;Now rsi points to that dummy value on the stack
   146 000000B2 B800000000              mov qword rax, 0                 	;No vector registers
   147 000000B7 E8(00000000)            call scanf                       	;Call the external function; the new value is placed into the location that rsi points to
   148 000000BC 415F                    pop qword r15                          	;First inputted integer is saved in r15
   149 000000BE 58                      pop rax
   150 000000BF 4C893C25[10000000]      mov [input], r15								
   151                                  ;; Receive input _END
   152                                  
   153                                  
   154                                  ;===================================Debug Section================================================
   155                                  ;; DEBUG INPUT
   156 000000C7 48BF-                   mov rdi, dbg_input
   156 000000C9 [F101000000000000] 
   157 000000D1 488B3425[10000000]      mov rsi, [input]
   158 000000D9 B800000000              mov rax, 0
   159                                  ;call printf
   160                                  ;; DEBUG INPUT _END					
   161                                  ;===================================Debug Section================================================
   162                                  
   163 000000DE 41BF00000000            mov r15, 0                                  ; Initialize the loop counter to 0
   164 000000E4 4C8B3425[10000000]      mov r14, [input]					        ; Initialize counter validation to inputted value
   165 000000EC F2440F103C25-           movsd xmm15, [fHarmonNumerator]		  		; xmm15 = hsum numerator, always 1
   165 000000F2 [20000000]         
   166                                  
   167                                  
   168                                  
   169                                  ;================================================================================================
   170                                  ;================================================================================================
   171                                  ;====================CODE STABLE UP TO THIS POINT. SEG FAULT DOWN BELOW==========================
   172                                  ;========================EDIT(12-16-2020). SEG FAULT RESOLVED====================================
   173                                  
   174 000000F6 48BF-                   mov rdi, dbg_input			; 
   174 000000F8 [F101000000000000] 
   175 00000100 4C89F6                  mov rsi, r14
   176                                  ;call printf
   177                                  
   178                                  ;===================================Debug Section================================================
   179                                  ; DEBUG HSUM NUMERATOR
   180 00000103 F20F100425-             movsd xmm0, [fHarmonNumerator]
   180 00000108 [20000000]         
   181 0000010C B801000000              mov rax, 1
   182 00000111 48BF-                   mov rdi, dbg_float
   182 00000113 [1902000000000000] 
   183                                  ;call printf
   184                                  ; DEBUG HSUM NUMERATOR _END
   185                                  
   186                                  ;; DEBUG tics (START)
   187 0000011B 4831C0                  xor rax, rax
   188 0000011E 0F31                    rdtsc
   189 00000120 890425[00000000]        mov [start_tics], eax		; Lower half of RDTSC will be in eax
   190 00000127 891425[04000000]        mov [start_tics+4], edx		; Upper half of RDTSC will be in edx
   191 0000012E 48BF-                   mov rdi, initial_tics			; First parameter for printf
   191 00000130 [B200000000000000] 
   192 00000138 488B3425[00000000]      mov rsi, [start_tics]		; Second parameter for printf
   193 00000140 E8(00000000)            call printf
   194                                  ;; DEBUG tics (START) _END
   195                                  
   196                                  ;;	Output Column Head
   197 00000145 B800000000              mov qword rax, 0
   198 0000014A 48BF-                   mov rdi, stringFormat
   198 0000014C [2C00000000000000] 
   199 00000154 48BE-                   mov rsi, column_head
   199 00000156 [EE00000000000000] 
   200 0000015E E8(00000000)            call printf
   201                                  ;;	Output Column Head _END
   202                                  
   203                                  ;===================================Loop Start===================================================
   204                                  hsum_loop:
   205                                  
   206                                  ;;	Loop Validation
   207 00000163 4831C0                  xor rax, rax                       ;No data from the SSE will be printed
   208 00000166 4983FE00                cmp r14, 0							; Compares r15 to r14
   209 0000016A 7E72                    jle non_positive_input					; If r15 >= r14, input received is <= 1
   210                                  ;;	Loop Validation _END
   211                                  
   212                                  
   213                                  
   214                                  ;;	Loop Body
   215 0000016C 49FFC7                  inc r15									; increment r15. Loop Counter and denominator
   216 0000016F F24D0F2AF7              cvtsi2sd xmm14, r15						; Converts r15(Denominator) to xmm14 register
   217 00000174 F2440F103C25-           movsd xmm15, [fHarmonNumerator]
   217 0000017A [20000000]         
   218 0000017E F2450F5EFE              divsd xmm15, xmm14						; Division of Numerator(xmm15) by Denominator(xmm14)
   219                                  
   220                                  
   221                                  
   222                                  ; Add harmonic increment to sum
   223 00000183 F2440F102C25-           movsd xmm13, [output]
   223 00000189 [18000000]         
   224 0000018D F2450F58EF              addsd xmm13, xmm15						; Adds the latest division to output total
   225 00000192 F2440F112C25-           movsd [output], xmm13
   225 00000198 [18000000]         
   226                                  
   227                                  
   228                                  ; Validation for output of terms
   229 0000019C 4C89F8                  mov rax, r15
   230 0000019F 41B908000000            mov r9, 8
   231 000001A5 4899                    cqo
   232 000001A7 49F7F9                  idiv r9									; rdx = rax(loop counter) % 8
   233 000001AA 4883FA00                cmp rdx, 0								
   234 000001AE 7407                    je term_output							; if counter is a multiple of 8, output the term
   235                                  ; Validation to continue Loop
   236 000001B0 4D39F7                  cmp r15, r14							; if loop counter == input value...
   237 000001B3 743D                    je loop_end								; ... jump to closing statements
   238 000001B5 EBAC                    jmp hsum_loop							; else start hsum_loop all over again
   239                                  ;;	Loop Body _END
   240                                  
   241                                  ;;	Term Output
   242                                  term_output:							;loop if term needs to be outputted
   243 000001B7 B801000000              mov rax, 1
   244 000001BC 48BF-                   mov rdi, row_hsum
   244 000001BE [0D01000000000000] 
   245 000001C6 4C89FE                  mov rsi, r15
   246 000001C9 F20F100425-             movsd xmm0, [output]
   246 000001CE [18000000]         
   247 000001D2 E8(00000000)            call printf
   248                                  ; Validation to continue Loop
   249 000001D7 4D39F7                  cmp r15, r14							; if loop counter == input value...
   250 000001DA 7416                    je loop_end								; ... jump to closing statements
   251 000001DC EB85                    jmp hsum_loop							; else start hsum_loop all over again
   252                                  ;;	Term Output _END
   253                                  ;===================================Loop End===================================================
   254                                  
   255                                  non_positive_input:
   256 000001DE 48BF-                   mov rdi, error_msg
   256 000001E0 [6D00000000000000] 
   257 000001E8 B800000000              mov rax, 0
   258 000001ED E8(00000000)            call printf
   259                                  
   260                                  
   261                                  loop_end:
   262                                  
   263                                  ;; DEBUG tics (CLOSE)
   264 000001F2 4831C0                  xor rax, rax
   265 000001F5 0F31                    rdtsc
   266 000001F7 890425[08000000]        mov [close_tics], eax		; Lower half of RDTSC will be in eax
   267 000001FE 891425[0C000000]        mov [close_tics+4], edx		; Upper half of RDTSC will be in edx
   268 00000205 48BF-                   mov rdi, dbg_tics			; First parameter for printf
   268 00000207 [B901000000000000] 
   269 0000020F 488B3425[08000000]      mov rsi, [close_tics]		; Second parameter for printf
   270                                  ;call printf
   271                                  ; DEBUG tics (CLOSE) _END
   272                                  
   273 00000217 48BF-                   mov rdi, final_tics
   273 00000219 [1A01000000000000] 
   274 00000221 B800000000              mov rax, 0
   275 00000226 488B3425[08000000]      mov rsi, [close_tics]
   276                                  ;movsd xmm0, [output]
   277 0000022E E8(00000000)            call printf
   278                                  
   279                                  
   280                                  ; DEBUG SECONDS
   281                                  ; getfreq -> xmm15
   282 00000233 4831C0                  xor rax, rax
   283 00000236 E8(00000000)            call getfreq
   284 0000023B 4C8B3C25[08000000]      mov r15, [close_tics]
   285 00000243 4C2B3C25[00000000]      sub r15, [start_tics]
   286 0000024B F24D0F2AEF              cvtsi2sd xmm13, r15
   287 00000250 B800000000              mov rax, 0
   288 00000255 F2440F10F8              movsd xmm15, xmm0
   289                                  ; Math part
   290 0000025A 49BD0000000065CDCD-     mov r13, 0x41cdcd6500000000	; 1 billion
   290 00000263 41                 
   291 00000264 664D0F6EE5              movq xmm12, r13				; xmm12 = 1bil
   292 00000269 F2450F10F7              movsd xmm14, xmm15			; xmm14 = Clock Speed
   293 0000026E F2450F59F4              mulsd xmm14, xmm12			; xmm14 = Clock Speed * 1bil
   294 00000273 F2450F5EEE              divsd xmm13, xmm14			; xmm13 = Elapsed time / (GHz * 1bil)
   295                                  ; printf part
   296 00000278 B801000000              mov rax, 1
   297 0000027D 48BF-                   mov rdi, time
   297 0000027F [3701000000000000] 
   298 00000287 4C89FE                  mov rsi, r15
   299 0000028A F2410F10C5              movsd xmm0, xmm13
   300 0000028F E8(00000000)            call printf
   301                                  ;; DEBUG SECONDS _END
   302                                  
   303 00000294 48BF-                   mov rdi, exit_msg
   303 00000296 [7001000000000000] 
   304 0000029E 488B0425[18000000]      mov rax, [output]
   305 000002A6 E8(00000000)            call printf
   306                                  
   307                                  
   308 000002AB F20F100425-             movsd xmm0, [output]
   308 000002B0 [18000000]         
   309                                  
   310                                  ;==================================== Restore GPRs ====================================
   311 000002B4 9D                        popf              ;Restore rflags
   312 000002B5 415F                      pop   r15         ;Restore r15
   313 000002B7 415E                      pop   r14         ;Restore r14
   314 000002B9 415D                      pop   r13         ;Restore r13
   315 000002BB 415C                      pop   r12         ;Restore r12
   316 000002BD 415B                      pop   r11         ;Restore r11
   317 000002BF 415A                      pop   r10         ;Restore r10
   318 000002C1 4159                      pop   r9          ;Restore r9
   319 000002C3 4158                      pop   r8          ;Restore r8
   320 000002C5 5F                        pop   rdi         ;Restore rdi
   321 000002C6 5E                        pop   rsi         ;Restore rsi
   322 000002C7 5A                        pop   rdx         ;Restore rdx
   323 000002C8 59                        pop   rcx         ;Restore rcx
   324 000002C9 5B                        pop   rbx         ;Restore rbx
   325 000002CA 5D                        pop   rbp         ;Return rbp to point to the base of the activation record of the caller.
   326                                  ;======================================================================================
   327                                  
   328 000002CB C3                        ret
