     1                                  ;==============================================================================================================
     2                                  ;Program name: "Harmonic Sum". This program is meant to calculate the 
     3                                  ;   Harmonic Sum of an inputted integer. Copyright (C) 2020 Dennis Newman
     4                                  ;This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License  *
     5                                  ;version 3 as published by the Free Software Foundation.                                                                    *
     6                                  ;This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied         *
     7                                  ;Warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.     *
     8                                  ;A copy of the GNU General Public License v3 is available here:  <https://www.gnu.org/licenses/>.
     9                                  ;==============================================================================================================
    10                                  
    11                                  ;==============================================================================================================
    12                                  ;Author Information
    13                                  ;       Author Name: Dennis Newman
    14                                  ;       Author email: dlnew3@csu.fullerton.edu
    15                                  ;;
    16                                  ;Program Information
    17                                  ;   Program Name: Harmonic Sum
    18                                  ;   Program Languages: One module in C++, two modules in x86
    19                                  ;   Date Program began: Dec. 8, 2020
    20                                  ;   Date Program completed:
    21                                  ;   Files in this program: main.cpp, manager.asm, read_clock.asm, r.sh
    22                                  ;   Status: In Progress
    23                                  ;;
    24                                  ;References for this program
    25                                  ;   Jorgensen, X86-64 Assembly Language Programming with Ubuntu, Version 1.1.40.
    26                                  ;;
    27                                  ;This File
    28                                  ;   File Name: manager.asm
    29                                  ;   Language: x86-64 with Intel Syntax
    30                                  ;   Assemble: nasm -f elf64 -l manager.lis -o manager.o manager.asm
    31                                  
    32                                  ;======= Beginning of Code Area ===================================================================================================
    33                                  
    34                                  extern printf               ;External C++ function for writing to standard output devices
    35                                  extern scanf                ;External C++ function for reading from standard input devices
    36                                  extern getfreq          ;User-Defined function
    37                                  ;extern atof
    38                                  
    39                                  
    40                                  ;==================================================================================================================================
    41                                  segment .data               ;Initialized Data goes here
    42                                  
    43 00000000 0000000000000000        start_tics dq 0
    44 00000008 0000000000000000        close_tics dq 0
    45 00000010 0000000000000000        input dq 0
    46 00000018 0000000000000000        output dq 0
    47 00000020 000000000000F03F        fHarmonNumerator dq 1.0
    48                                  
    49 00000028 256C6400                numberFormat db "%ld", 0
    50 0000002C 257300                  stringFormat db "%s", 0
    51                                  
    52 0000002F 506C6561736520656E-     input_msg db "Please enter the number of terms to be included in the sum: ", 10, 0
    52 00000038 74657220746865206E-
    52 00000041 756D626572206F6620-
    52 0000004A 7465726D7320746F20-
    52 00000053 626520696E636C7564-
    52 0000005C 656420696E20746865-
    52 00000065 2073756D3A200A00   
    53 0000006D 4572726F723A20496E-     error_msg db "Error: Inputted value is not a positive integer, closing program...", 10, 0
    53 00000076 707574746564207661-
    53 0000007F 6C7565206973206E6F-
    53 00000088 74206120706F736974-
    53 00000091 69766520696E746567-
    53 0000009A 65722C20636C6F7369-
    53 000000A3 6E672070726F677261-
    53 000000AC 6D2E2E2E0A00       
    54 000000B2 0A54686520636C6F63-     initial_tics db 10, "The clock is now %ld tics and the computation will begin.", 10, 0
    54 000000BB 6B206973206E6F7720-
    54 000000C4 256C64207469637320-
    54 000000CD 616E64207468652063-
    54 000000D6 6F6D7075746174696F-
    54 000000DF 6E2077696C6C206265-
    54 000000E8 67696E2E0A00       
    55 000000EE 0A5465726D7320636F-     column_head db 10, "Terms completed", 9, "Harmonic sum", 10 , 0
    55 000000F7 6D706C657465640948-
    55 00000100 61726D6F6E69632073-
    55 00000109 756D0A00           
    56 0000010D 09256C6409252E3138-     row_hsum db 9, "%ld", 9, "%.18lf", 10, 0
    56 00000116 6C660A00           
    57 0000011A 0A54686520636C6F63-     final_tics db 10, "The clock is now %ld tics.", 10, 0
    57 00000123 6B206973206E6F7720-
    57 0000012C 256C6420746963732E-
    57 00000135 0A00               
    58 00000137 54686520656C617073-     time db "The elapsed time was %ld tics, which equals %lf seconds", 10, 0
    58 00000140 65642074696D652077-
    58 00000149 617320256C64207469-
    58 00000152 63732C207768696368-
    58 0000015B 20657175616C732025-
    58 00000164 6C66207365636F6E64-
    58 0000016D 730A00             
    59 00000170 546865206861726D6F-     exit_msg db "The harmonic sum will be returned to the driver.", 10, 0
    59 00000179 6E69632073756D2077-
    59 00000182 696C6C206265207265-
    59 0000018B 7475726E656420746F-
    59 00000194 207468652064726976-
    59 0000019D 65722E0A00         
    60                                  
    61                                  
    62                                  
    63                                  global hsum     	        ;Makes manager callable by functions outside of file.
    64                                  
    65                                  segment .bss
    66                                  
    67                                  
    68                                  segment .text
    69                                  hsum:
    70                                  
    71                                  ;==================================== Back-up GPRs ====================================
    72 00000000 55                        push  rbp         ;Save a copy of the stack base pointer
    73 00000001 4889E5                    mov   rbp, rsp    ;We do this in order to be 100% compatible with C and C++.
    74 00000004 53                        push  rbx         ;Back up rbx
    75 00000005 51                        push  rcx         ;Back up rcx
    76 00000006 52                        push  rdx         ;Back up rdx
    77 00000007 56                        push  rsi         ;Back up rsi
    78 00000008 57                        push  rdi         ;Back up rdi
    79 00000009 4150                      push  r8          ;Back up r8
    80 0000000B 4151                      push  r9          ;Back up r9
    81 0000000D 4152                      push  r10         ;Back up r10
    82 0000000F 4153                      push  r11         ;Back up r11
    83 00000011 4154                      push  r12         ;Back up r12
    84 00000013 4155                      push  r13         ;Back up r13
    85 00000015 4156                      push  r14         ;Back up r14
    86 00000017 4157                      push  r15         ;Back up r15
    87 00000019 9C                        pushf             ;Back up rflags
    88                                  
    89                                  ;======================================================================================
    90                                  
    91                                  
    92                                  
    93                                  ;;	Input Message
    94 0000001A B800000000              mov rax, 0
    95 0000001F 48BF-                   mov rdi, input_msg
    95 00000021 [2F00000000000000] 
    96 00000029 E8(00000000)            call printf
    97                                  ;;	Input Message _END
    98                                  
    99                                  ;;	Receive input
   100 0000002E 48BF-                   mov qword rdi, numberFormat
   100 00000030 [2800000000000000] 
   101 00000038 6AFF                    push qword -1                     	;Reserve space for input
   102 0000003A 6AFF                    push qword -1
   103 0000003C 4889E6                  mov qword rsi, rsp               	;Now rsi points to that dummy value on the stack
   104 0000003F B800000000              mov qword rax, 0                 	;No vector registers
   105 00000044 E8(00000000)            call scanf                       	;Call the external function; the new value is placed into the location that rsi points to
   106 00000049 415F                    pop qword r15                          	;First inputted integer is saved in r15
   107 0000004B 58                      pop rax
   108 0000004C 4C893C25[10000000]      mov [input], r15								
   109                                  ;; Receive input _END
   110                                  
   111                                  ;======================================Loop Initialization=====================================
   112                                  
   113 00000054 41BF00000000            mov r15, 0                                  ; Initialize the loop counter to 0
   114 0000005A 4C8B3425[10000000]      mov r14, [input]					        ; Initialize counter validation to inputted value
   115 00000062 F2440F103C25-           movsd xmm15, [fHarmonNumerator]		  		; xmm15 = hsum numerator, always 1
   115 00000068 [20000000]         
   116                                  
   117                                  
   118                                  ;	Initial Tics
   119 0000006C 4831C0                  xor rax, rax
   120 0000006F 0F31                    rdtsc
   121 00000071 890425[00000000]        mov [start_tics], eax		; Lower half of RDTSC will be in eax
   122 00000078 891425[04000000]        mov [start_tics+4], edx		; Upper half of RDTSC will be in edx
   123 0000007F 48BF-                   mov rdi, initial_tics			; First parameter for printf
   123 00000081 [B200000000000000] 
   124 00000089 488B3425[00000000]      mov rsi, [start_tics]		; Second parameter for printf
   125 00000091 E8(00000000)            call printf
   126                                  
   127                                  
   128                                  ;;	Output Column Head
   129 00000096 B800000000              mov qword rax, 0
   130 0000009B 48BF-                   mov rdi, stringFormat
   130 0000009D [2C00000000000000] 
   131 000000A5 48BE-                   mov rsi, column_head
   131 000000A7 [EE00000000000000] 
   132 000000AF E8(00000000)            call printf
   133                                  ;;	Output Column Head _END
   134                                  
   135                                  ;===================================Loop Start===================================================
   136                                  hsum_loop:
   137                                  
   138                                  ;;	Loop Validation
   139 000000B4 4831C0                  xor rax, rax                       ;No data from the SSE will be printed
   140 000000B7 4983FE00                cmp r14, 0							; Compares r15 to r14
   141 000000BB 7E72                    jle non_positive_input					; If r15 >= r14, input received is <= 1
   142                                  ;;	Loop Validation _END
   143                                  
   144                                  
   145                                  ;;	Loop Body
   146 000000BD 49FFC7                  inc r15									; increment r15. Loop Counter and denominator
   147 000000C0 F24D0F2AF7              cvtsi2sd xmm14, r15						; Converts r15(Denominator) to xmm14 register
   148 000000C5 F2440F103C25-           movsd xmm15, [fHarmonNumerator]
   148 000000CB [20000000]         
   149 000000CF F2450F5EFE              divsd xmm15, xmm14						; Division of Numerator(xmm15) by Denominator(xmm14)
   150                                  
   151                                  ; Add harmonic increment to sum
   152 000000D4 F2440F102C25-           movsd xmm13, [output]
   152 000000DA [18000000]         
   153 000000DE F2450F58EF              addsd xmm13, xmm15						; Adds the latest division to output total
   154 000000E3 F2440F112C25-           movsd [output], xmm13
   154 000000E9 [18000000]         
   155                                  
   156                                  ; Validation for output of terms
   157 000000ED 4C89F8                  mov rax, r15
   158 000000F0 41B908000000            mov r9, 8
   159 000000F6 4899                    cqo
   160 000000F8 49F7F9                  idiv r9									; rdx = rax(loop counter) % 8
   161 000000FB 4883FA00                cmp rdx, 0								
   162 000000FF 7407                    je term_output							; if counter is a multiple of 8, output the term
   163                                  ; Validation to continue Loop
   164 00000101 4D39F7                  cmp r15, r14							; if loop counter == input value...
   165 00000104 743D                    je loop_end								; ... jump to closing statements
   166 00000106 EBAC                    jmp hsum_loop							; else start hsum_loop all over again
   167                                  ;;	Loop Body _END
   168                                  
   169                                  
   170                                  
   171                                  ;;	Term Output
   172                                  term_output:							;loop if term needs to be outputted
   173 00000108 B801000000              mov rax, 1
   174 0000010D 48BF-                   mov rdi, row_hsum
   174 0000010F [0D01000000000000] 
   175 00000117 4C89FE                  mov rsi, r15
   176 0000011A F20F100425-             movsd xmm0, [output]
   176 0000011F [18000000]         
   177 00000123 E8(00000000)            call printf
   178                                  ; Validation to continue Loop
   179 00000128 4D39F7                  cmp r15, r14							; if loop counter == input value...
   180 0000012B 7416                    je loop_end								; ... jump to closing statements
   181 0000012D EB85                    jmp hsum_loop							; else start hsum_loop all over again
   182                                  ;;	Term Output _END 
   183                                  
   184                                  ;===================================Loop End===================================================
   185                                  ;	Jump for invalid input
   186                                  non_positive_input:
   187 0000012F 48BF-                   mov rdi, error_msg
   187 00000131 [6D00000000000000] 
   188 00000139 B800000000              mov rax, 0
   189 0000013E E8(00000000)            call printf
   190                                  
   191                                  loop_end:
   192                                  
   193 00000143 4831C0                  xor rax, rax
   194 00000146 0F31                    rdtsc
   195 00000148 890425[08000000]        mov [close_tics], eax		; Lower half of RDTSC will be in eax
   196 0000014F 891425[0C000000]        mov [close_tics+4], edx		; Upper half of RDTSC will be in edx
   197                                  
   198                                  
   199 00000156 48BF-                   mov rdi, final_tics
   199 00000158 [1A01000000000000] 
   200 00000160 B800000000              mov rax, 0
   201 00000165 488B3425[08000000]      mov rsi, [close_tics]
   202 0000016D E8(00000000)            call printf
   203                                  
   204                                  
   205 00000172 4831C0                  xor rax, rax
   206 00000175 E8(00000000)            call getfreq
   207 0000017A 4C8B3C25[08000000]      mov r15, [close_tics]
   208 00000182 4C2B3C25[00000000]      sub r15, [start_tics]
   209 0000018A F24D0F2AEF              cvtsi2sd xmm13, r15
   210 0000018F B800000000              mov rax, 0
   211 00000194 F2440F10F8              movsd xmm15, xmm0
   212                                  ; Math part
   213 00000199 49BD0000000065CDCD-     mov r13, 0x41cdcd6500000000	; 1 billion
   213 000001A2 41                 
   214 000001A3 664D0F6EE5              movq xmm12, r13				; xmm12 = 1bil
   215 000001A8 F2450F10F7              movsd xmm14, xmm15			; xmm14 = Clock Speed
   216 000001AD F2450F59F4              mulsd xmm14, xmm12			; xmm14 = Clock Speed * 1bil
   217 000001B2 F2450F5EEE              divsd xmm13, xmm14			; xmm13 = Elapsed time / (GHz * 1bil)
   218                                  ; printf part
   219 000001B7 B801000000              mov rax, 1
   220 000001BC 48BF-                   mov rdi, time
   220 000001BE [3701000000000000] 
   221 000001C6 4C89FE                  mov rsi, r15
   222 000001C9 F2410F10C5              movsd xmm0, xmm13
   223 000001CE E8(00000000)            call printf
   224                                  
   225                                  
   226                                  
   227                                  
   228                                  
   229 000001D3 48BF-                   mov rdi, exit_msg
   229 000001D5 [7001000000000000] 
   230 000001DD 488B0425[18000000]      mov rax, [output]
   231 000001E5 E8(00000000)            call printf
   232                                  
   233                                  
   234 000001EA F20F100425-             movsd xmm0, [output]
   234 000001EF [18000000]         
   235                                  
   236                                  ;==================================== Restore GPRs ====================================
   237 000001F3 9D                        popf              ;Restore rflags
   238 000001F4 415F                      pop   r15         ;Restore r15
   239 000001F6 415E                      pop   r14         ;Restore r14
   240 000001F8 415D                      pop   r13         ;Restore r13
   241 000001FA 415C                      pop   r12         ;Restore r12
   242 000001FC 415B                      pop   r11         ;Restore r11
   243 000001FE 415A                      pop   r10         ;Restore r10
   244 00000200 4159                      pop   r9          ;Restore r9
   245 00000202 4158                      pop   r8          ;Restore r8
   246 00000204 5F                        pop   rdi         ;Restore rdi
   247 00000205 5E                        pop   rsi         ;Restore rsi
   248 00000206 5A                        pop   rdx         ;Restore rdx
   249 00000207 59                        pop   rcx         ;Restore rcx
   250 00000208 5B                        pop   rbx         ;Restore rbx
   251 00000209 5D                        pop   rbp         ;Return rbp to point to the base of the activation record of the caller.
   252                                  ;======================================================================================
   253                                  
   254 0000020A C3                        ret
