     1                                  ;==============================================================================================================
     2                                  ;Program name: "Harmonic Sum". This program is meant to calculate the 
     3                                  ;   Harmonic Sum of an inputted integer. Copyright (C) 2020 Dennis Newman
     4                                  ;This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License  *
     5                                  ;version 3 as published by the Free Software Foundation.                                                                    *
     6                                  ;This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied         *
     7                                  ;Warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.     *
     8                                  ;A copy of the GNU General Public License v3 is available here:  <https://www.gnu.org/licenses/>.
     9                                  ;==============================================================================================================
    10                                  
    11                                  ;==============================================================================================================
    12                                  ;Author Information
    13                                  ;       Author Name: Dennis Newman
    14                                  ;       Author email: dlnew3@csu.fullerton.edu
    15                                  ;;
    16                                  ;Program Information
    17                                  ;   Program Name: Harmonic Sum
    18                                  ;   Program Languages: One module in C++, two modules in x86
    19                                  ;   Date Program began: Dec. 8, 2020
    20                                  ;   Date Program completed:
    21                                  ;   Files in this program: main.cpp, manager.asm, read_clock.asm, r.sh
    22                                  ;   Status: In Progress
    23                                  ;;
    24                                  ;References for this program
    25                                  ;   Jorgensen, X86-64 Assembly Language Programming with Ubuntu, Version 1.1.40.
    26                                  ;;
    27                                  ;This File
    28                                  ;   File Name: manager.asm
    29                                  ;   Language: x86-64 with Intel Syntax
    30                                  ;   Assemble: nasm -f elf64 -l manager.lis -o manager.o manager.asm
    31                                  
    32                                  ;======= Beginning of Code Area ===================================================================================================
    33                                  
    34                                  extern printf               ;External C++ function for writing to standard output devices
    35                                  extern scanf                ;External C++ function for reading from standard input devices
    36                                  extern getfreq          ;User-Defined function
    37                                  ;extern atof
    38                                  
    39                                  
    40                                  ;==================================================================================================================================
    41                                  segment .data               ;Initialized Data goes here
    42                                  
    43 00000000 0000000000000000        start_tics dq 0
    44 00000008 0000000000000000        close_tics dq 0
    45 00000010 0000000000000000        input dq 0
    46 00000018 0000000000000000        output dq 0
    47 00000020 000000000000F03F        fHarmonNumerator dq 1.0
    48                                  
    49 00000028 256C6400                numberFormat db "%ld", 0
    50 0000002C 257300                  stringFormat db "%s", 0
    51                                  
    52 0000002F 506C6561736520656E-     input_msg db "Please enter the number of terms to be included in the sum: ", 10, 0
    52 00000038 74657220746865206E-
    52 00000041 756D626572206F6620-
    52 0000004A 7465726D7320746F20-
    52 00000053 626520696E636C7564-
    52 0000005C 656420696E20746865-
    52 00000065 2073756D3A200A00   
    53 0000006D 4572726F723A20496E-     error_msg db "Error: Inputted value is not a positive integer, closing program...", 10, 0
    53 00000076 707574746564207661-
    53 0000007F 6C7565206973206E6F-
    53 00000088 74206120706F736974-
    53 00000091 69766520696E746567-
    53 0000009A 65722C20636C6F7369-
    53 000000A3 6E672070726F677261-
    53 000000AC 6D2E2E2E0A00       
    54 000000B2 0A54686520636C6F63-     initial_tics db 10, "The clock is now %ld tics and the computation will begin.", 10, 0
    54 000000BB 6B206973206E6F7720-
    54 000000C4 256C64207469637320-
    54 000000CD 616E64207468652063-
    54 000000D6 6F6D7075746174696F-
    54 000000DF 6E2077696C6C206265-
    54 000000E8 67696E2E0A00       
    55 000000EE 0A5465726D7320636F-     column_head db 10, "Terms completed", 9, "Harmonic sum", 10 , 0
    55 000000F7 6D706C657465640948-
    55 00000100 61726D6F6E69632073-
    55 00000109 756D0A00           
    56 0000010D 09256C6409256C660A-     row_hsum db 9, "%ld", 9, "%lf", 10, 0
    56 00000116 00                 
    57 00000117 0A54686520636C6F63-     final_tics db 10, "The clock is now %ld tics, which equals %lf seconds.", 10, 0
    57 00000120 6B206973206E6F7720-
    57 00000129 256C6420746963732C-
    57 00000132 207768696368206571-
    57 0000013B 75616C7320256C6620-
    57 00000144 7365636F6E64732E0A-
    57 0000014D 00                 
    58 0000014E 546865206861726D6F-     exit_msg db "The harmonic sum will be returned to the driver.", 10, 0
    58 00000157 6E69632073756D2077-
    58 00000160 696C6C206265207265-
    58 00000169 7475726E656420746F-
    58 00000172 207468652064726976-
    58 0000017B 65722E0A00         
    59                                  
    60                                  ;============Debug Statements==============
    61 00000180 436C6F636B20537065-     dbg_getfreq db "Clock Speed is %f GHz", 10, 0
    61 00000189 656420697320256620-
    61 00000192 47487A0A00         
    62 00000197 43757272656E742074-     dbg_tics db "Current tics = %ld tics", 10, 0
    62 000001A0 696373203D20256C64-
    62 000001A9 20746963730A00     
    63 000001B0 456C61707365642073-     dbg_seconds db "Elapsed seconds = %.12lf seconds", 10, 0
    63 000001B9 65636F6E6473203D20-
    63 000001C2 252E31326C66207365-
    63 000001CB 636F6E64730A00     
    64 000001D2 526563656976656420-     dbg_input db "Received input = %ld.", 10, 0
    64 000001DB 696E707574203D2025-
    64 000001E4 6C642E0A00         
    65 000001E9 426C6F636B20636F6D-     dbg_block_conf db "Block completed", 10, 0 
    65 000001F2 706C657465640A00   
    66 000001FA 256C660A00              dbg_float db "%lf", 10, 0
    67                                  ;============Debug Statements==============
    68                                  
    69                                  global hsum     	        ;Makes manager callable by functions outside of file.
    70                                  
    71                                  segment .bss
    72                                  
    73                                  
    74                                  segment .text
    75                                  hsum:
    76                                  
    77                                  ;==================================== Back-up GPRs ====================================
    78 00000000 55                        push  rbp         ;Save a copy of the stack base pointer
    79 00000001 4889E5                    mov   rbp, rsp    ;We do this in order to be 100% compatible with C and C++.
    80 00000004 53                        push  rbx         ;Back up rbx
    81 00000005 51                        push  rcx         ;Back up rcx
    82 00000006 52                        push  rdx         ;Back up rdx
    83 00000007 56                        push  rsi         ;Back up rsi
    84 00000008 57                        push  rdi         ;Back up rdi
    85 00000009 4150                      push  r8          ;Back up r8
    86 0000000B 4151                      push  r9          ;Back up r9
    87 0000000D 4152                      push  r10         ;Back up r10
    88 0000000F 4153                      push  r11         ;Back up r11
    89 00000011 4154                      push  r12         ;Back up r12
    90 00000013 4155                      push  r13         ;Back up r13
    91 00000015 4156                      push  r14         ;Back up r14
    92 00000017 4157                      push  r15         ;Back up r15
    93 00000019 9C                        pushf             ;Back up rflags
    94                                  
    95                                  ;======================================================================================
    96                                  
    97                                  ;===================================Debug Section================================================
    98                                  ;; DEBUG getfreq
    99 0000001A 4831C0                  xor rax, rax
   100 0000001D E8(00000000)            call getfreq
   101 00000022 B801000000              mov rax, 1
   102 00000027 48BF-                   mov rdi, dbg_getfreq
   102 00000029 [8001000000000000] 
   103 00000031 E8(00000000)            call printf
   104                                  ;; DEBUG getfreq _END
   105                                  
   106                                  ;; DEBUG tics (START)
   107 00000036 4831C0                  xor rax, rax
   108 00000039 0F31                    rdtsc
   109 0000003B 890425[00000000]        mov [start_tics], eax		; Lower half of RDTSC will be in eax
   110 00000042 891425[04000000]        mov [start_tics+4], edx		; Upper half of RDTSC will be in edx
   111 00000049 48BF-                   mov rdi, dbg_tics			; First parameter for printf
   111 0000004B [9701000000000000] 
   112 00000053 488B3425[00000000]      mov rsi, [start_tics]		; Second parameter for printf
   113 0000005B E8(00000000)            call printf
   114                                  ;; DEBUG tics (START) _END
   115                                  
   116                                  ;; DEBUG tics (CLOSE)
   117 00000060 4831C0                  xor rax, rax
   118 00000063 0F31                    rdtsc
   119 00000065 890425[08000000]        mov [close_tics], eax		; Lower half of RDTSC will be in eax
   120 0000006C 891425[0C000000]        mov [close_tics+4], edx		; Upper half of RDTSC will be in edx
   121 00000073 48BF-                   mov rdi, dbg_tics			; First parameter for printf
   121 00000075 [9701000000000000] 
   122 0000007D 488B3425[08000000]      mov rsi, [close_tics]		; Second parameter for printf
   123 00000085 E8(00000000)            call printf
   124                                  ; DEBUG tics (CLOSE) _END
   125                                  
   126                                  ;; DEBUG SECONDS
   127                                  ; getfreq -> xmm15
   128 0000008A 4831C0                  xor rax, rax
   129 0000008D E8(00000000)            call getfreq
   130 00000092 4C8B3C25[08000000]      mov r15, [close_tics]
   131 0000009A 4C2B3C25[00000000]      sub r15, [start_tics]
   132 000000A2 F24D0F2AEF              cvtsi2sd xmm13, r15
   133 000000A7 B800000000              mov rax, 0
   134 000000AC F2440F10F8              movsd xmm15, xmm0
   135                                  ; Math part
   136 000000B1 49BD0000000065CDCD-     mov r13, 0x41cdcd6500000000	; 1 billion
   136 000000BA 41                 
   137 000000BB 664D0F6EE5              movq xmm12, r13				; xmm12 = 1bil
   138 000000C0 F2450F10F7              movsd xmm14, xmm15			; xmm14 = Clock Speed
   139 000000C5 F2450F59F4              mulsd xmm14, xmm12			; xmm14 = Clock Speed * 1bil
   140 000000CA F2450F5EEE              divsd xmm13, xmm14			; xmm13 = Elapsed time / (GHz * 1bil)
   141                                  ; printf part
   142 000000CF B801000000              mov rax, 1
   143 000000D4 48BF-                   mov rdi, dbg_seconds
   143 000000D6 [B001000000000000] 
   144 000000DE 4C89FE                  mov rsi, r15
   145 000000E1 F2410F10C5              movsd xmm0, xmm13
   146 000000E6 E8(00000000)            call printf
   147                                  ;; DEBUG SECONDS _END
   148                                  ;===================================Debug Section================================================
   149                                  
   150                                  
   151                                  ;;	Input Message
   152 000000EB B800000000              mov rax, 0
   153 000000F0 48BF-                   mov rdi, input_msg
   153 000000F2 [2F00000000000000] 
   154 000000FA E8(00000000)            call printf
   155                                  ;;	Input Message _END
   156                                  
   157                                  ;;	Receive input
   158 000000FF 48BF-                   mov qword rdi, numberFormat
   158 00000101 [2800000000000000] 
   159 00000109 6AFF                    push qword -1                     	;Reserve space for input
   160 0000010B 6AFF                    push qword -1
   161 0000010D 4889E6                  mov qword rsi, rsp               	;Now rsi points to that dummy value on the stack
   162 00000110 B800000000              mov qword rax, 0                 	;No vector registers
   163 00000115 E8(00000000)            call scanf                       	;Call the external function; the new value is placed into the location that rsi points to
   164 0000011A 415F                    pop qword r15                          	;First inputted integer is saved in r15
   165 0000011C 58                      pop rax
   166 0000011D 4C893C25[10000000]      mov [input], r15								
   167                                  ;; Receive input _END
   168                                  
   169                                  
   170                                  ;===================================Debug Section================================================
   171                                  ;; DEBUG INPUT
   172 00000125 48BF-                   mov rdi, dbg_input
   172 00000127 [D201000000000000] 
   173 0000012F 488B3425[10000000]      mov rsi, [input]
   174 00000137 B800000000              mov rax, 0
   175 0000013C E8(00000000)            call printf
   176                                  ;; DEBUG INPUT _END					
   177                                  ;===================================Debug Section================================================
   178                                  
   179 00000141 41BF00000000            mov r15, 0                                  ; Initialize the loop counter to 0
   180 00000147 4C8B3425[10000000]      mov r14, [input]					        ; Initialize counter validation to inputted value
   181 0000014F F2440F103C25-           movsd xmm15, [fHarmonNumerator]		  		; xmm15 = hsum numerator, always 1
   181 00000155 [20000000]         
   182                                  
   183                                  ;;	Output Column Head
   184 00000159 B800000000              mov qword rax, 0
   185 0000015E 48BF-                   mov rdi, stringFormat
   185 00000160 [2C00000000000000] 
   186 00000168 48BE-                   mov rsi, column_head
   186 0000016A [EE00000000000000] 
   187 00000172 E8(00000000)            call printf
   188                                  ;;	Output Column Head _END
   189                                  
   190                                  ;================================================================================================
   191                                  ;================================================================================================
   192                                  ;====================CODE STABLE UP TO THIS POINT. SEG FAULT DOWN BELOW==========================
   193                                  
   194 00000177 48BF-                   mov rdi, dbg_input			; 
   194 00000179 [D201000000000000] 
   195 00000181 4C89F6                  mov rsi, r14
   196 00000184 E8(00000000)            call printf
   197                                  
   198 00000189 F20F100425-             movsd xmm0, [fHarmonNumerator]
   198 0000018E [20000000]         
   199 00000192 B801000000              mov rax, 1
   200 00000197 48BF-                   mov rdi, dbg_float
   200 00000199 [FA01000000000000] 
   201 000001A1 E8(00000000)            call printf
   202                                  
   203                                  ;===================================Loop Start===================================================
   204                                  hsum_loop:
   205                                  
   206                                  ;;	Loop Validation
   207 000001A6 4831C0                  xor rax, rax                       ;No data from the SSE will be printed
   208 000001A9 4D39F7                  cmp r15, r14							; Compares r15 to r14
   209 000001AC 7F6D                    jg non_positive_input					; If r15 >= r14, input received is <= 1
   210                                  ;;	Loop Validation _END
   211                                  
   212                                  
   213                                  
   214                                  ;;	Loop Body
   215 000001AE 49FFC7                  inc r15									; increment r15. Loop Counter and denominator
   216 000001B1 F24D0F2AF7              cvtsi2sd xmm14, r15						; Converts r15(Denominator) to xmm14 register
   217 000001B6 F2440F103C25-           movsd xmm15, [fHarmonNumerator]
   217 000001BC [20000000]         
   218 000001C0 F2450F5EFE              divsd xmm15, xmm14						; Division of Numerator(xmm15) by Denominator(xmm14)
   219                                  
   220                                  
   221                                  
   222                                  ; Add harmonic increment to sum
   223 000001C5 F2440F102C25-           movsd xmm13, [output]
   223 000001CB [18000000]         
   224 000001CF F2450F58EF              addsd xmm13, xmm15						; Adds the latest division to output total
   225 000001D4 F2440F112C25-           movsd [output], xmm13
   225 000001DA [18000000]         
   226                                  
   227                                  
   228                                  ; Validation for output of terms
   229 000001DE 4C89F8                  mov rax, r15
   230 000001E1 41B90C000000            mov r9, 12
   231 000001E7 4899                    cqo
   232 000001E9 49F7F9                  idiv r9									; rdx = rax(loop counter) % 12
   233 000001EC 4883FA00                cmp rdx, 0								
   234 000001F0 7407                    je term_output							; if counter is a multiple of 12, output the term
   235                                  ; Validation to continue Loop
   236 000001F2 4D39F7                  cmp r15, r14							; if loop counter == input value...
   237 000001F5 7438                    je loop_end								; ... jump to closing statements
   238 000001F7 EBAD                    jmp hsum_loop							; else start hsum_loop all over again
   239                                  ;;	Loop Body _END
   240                                  
   241                                  ;;	Term Output
   242                                  term_output:							;loop if term needs to be outputted
   243 000001F9 B801000000              mov rax, 1
   244 000001FE 48BF-                   mov rdi, row_hsum
   244 00000200 [0D01000000000000] 
   245 00000208 4C89FE                  mov rsi, r15
   246 0000020B F20F100425-             movsd xmm0, [output]
   246 00000210 [18000000]         
   247 00000214 E8(00000000)            call printf
   248 00000219 EB8B                    jmp hsum_loop							;jumps back to start of hsum_loop
   249                                  ;;	Term Output _END
   250                                  ;===================================Loop End===================================================
   251                                  
   252                                  non_positive_input:
   253 0000021B 48BF-                   mov rdi, error_msg
   253 0000021D [6D00000000000000] 
   254 00000225 B800000000              mov rax, 0
   255 0000022A E8(00000000)            call printf
   256                                  
   257                                  
   258                                  loop_end:
   259 0000022F 48BF-                   mov rdi, final_tics
   259 00000231 [1701000000000000] 
   260 00000239 B801000000              mov rax, 1
   261 0000023E 4C89FE                  mov rsi, r15
   262 00000241 F20F100425-             movsd xmm0, [output]
   262 00000246 [18000000]         
   263 0000024A E8(00000000)            call printf
   264                                  
   265 0000024F 48BF-                   mov rdi, exit_msg
   265 00000251 [4E01000000000000] 
   266 00000259 488B0425[18000000]      mov rax, [output]
   267 00000261 E8(00000000)            call printf
   268                                  
   269                                  
   270                                  ;==================================== Restore GPRs ====================================
   271 00000266 9D                        popf              ;Restore rflags
   272 00000267 415F                      pop   r15         ;Restore r15
   273 00000269 415E                      pop   r14         ;Restore r14
   274 0000026B 415D                      pop   r13         ;Restore r13
   275 0000026D 415C                      pop   r12         ;Restore r12
   276 0000026F 415B                      pop   r11         ;Restore r11
   277 00000271 415A                      pop   r10         ;Restore r10
   278 00000273 4159                      pop   r9          ;Restore r9
   279 00000275 4158                      pop   r8          ;Restore r8
   280 00000277 5F                        pop   rdi         ;Restore rdi
   281 00000278 5E                        pop   rsi         ;Restore rsi
   282 00000279 5A                        pop   rdx         ;Restore rdx
   283 0000027A 59                        pop   rcx         ;Restore rcx
   284 0000027B 5B                        pop   rbx         ;Restore rbx
   285 0000027C 5D                        pop   rbp         ;Return rbp to point to the base of the activation record of the caller.
   286                                  ;======================================================================================
   287                                  
   288 0000027D C3                        ret
